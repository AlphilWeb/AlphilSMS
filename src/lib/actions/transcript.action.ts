// lib/actions/transcript.actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { db } from '@/lib/db/index';
import { transcripts, students, semesters, users } from '@/lib/db/schema'; // Import necessary schemas
import { eq, and } from 'drizzle-orm';
import { getAuthUser } from '@/lib/auth'; // Your provided auth utility
import { checkPermission } from '@/lib/rbac'; // Your provided RBAC utility
import { z } from 'zod';

// Define a custom error class for action failures
class ActionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ActionError';
  }
}

// Define ROLES constants for consistency and readability
const ROLES = {
  ADMIN: 'admin',
  REGISTRAR: 'registrar',
  HOD: 'hod',
  ACCOUNTANT: 'accountant',
  LECTURER: 'lecturer',
  STAFF: 'staff',
  STUDENT: 'student',
};

// Helper functions for common permission checks
function allowedRolesForManagingTranscripts() {
  return [ROLES.ADMIN, ROLES.REGISTRAR];
}

function allowedRolesForViewingAllTranscripts() {
  return [ROLES.ADMIN, ROLES.REGISTRAR];
}

function allowedRolesForViewingIndividualTranscript() {
  return [ROLES.ADMIN, ROLES.REGISTRAR, ROLES.STUDENT];
}

// Zod schema for creating a new transcript
const CreateTranscriptSchema = z.object({
  studentId: z
    .string()
    .transform(Number)
    .refine((num) => !isNaN(num) && num > 0, { message: 'Student ID must be a valid number.' }),
  semesterId: z
    .string()
    .transform(Number)
    .refine((num) => !isNaN(num) && num > 0, { message: 'Semester ID must be a valid number.' }),
  // Numeric fields: transform to number for validation, then back to string for Drizzle
  gpa: z
    .string()
    .nullable()
    .optional()
    .transform((val) => {
      const num = val === '' ? null : val ? parseFloat(val) : null;
      if (num === null) return null;
      if (isNaN(num) || num < 0 || num > 5)
        throw new Error('GPA must be a number between 0.00 and 5.00, or empty.');
      return num.toFixed(2); // Convert back to string with 2 decimal places for Drizzle numeric
    }),
  cgpa: z
    .string()
    .nullable()
    .optional()
    .transform((val) => {
      const num = val === '' ? null : val ? parseFloat(val) : null;
      if (num === null) return null;
      if (isNaN(num) || num < 0 || num > 5)
        throw new Error('CGPA must be a number between 0.00 and 5.00, or empty.');
      return num.toFixed(2); // Convert back to string with 2 decimal places for Drizzle numeric
    }),
  // generatedDate: Zod should parse to Date object for Drizzle timestamp
  generatedDate: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Generated Date must be in YYYY-MM-DD format.')
    .transform((str) => new Date(str)) // Transform to Date object
    .optional(), // Optional because it has defaultNow() in schema, if not provided it's generated by DB
  fileUrl: z.string().url('File URL must be a valid URL.').nullable().optional(),
});

// Zod schema for updating a transcript (all fields optional for partial updates)
const UpdateTranscriptSchema = CreateTranscriptSchema.partial();

/**
 * Creates a new transcript record.
 * Permissions: Admin ('admin'), Registrar ('registrar')
 * @param formData - FormData containing transcript details.
 * @returns A success message or an error object.
 */
export async function createTranscript(formData: FormData) {
  try {
    const authUser = await getAuthUser();
    if (!authUser || !checkPermission(authUser, allowedRolesForManagingTranscripts())) {
      return { error: 'Unauthorized: You do not have permission to create transcripts.' };
    }

    const parsed = CreateTranscriptSchema.safeParse({
      studentId: formData.get('studentId'),
      semesterId: formData.get('semesterId'),
      gpa: formData.get('gpa'),
      cgpa: formData.get('cgpa'),
      generatedDate: formData.get('generatedDate'),
      fileUrl: formData.get('fileUrl'),
    });

    if (!parsed.success) {
      console.error('Validation Error:', parsed.error.issues);
      return { error: parsed.error.issues.map((e) => e.message).join(', ') };
    }

    // Check for existing transcript for the same student and semester
    const existingTranscript = await db.query.transcripts.findFirst({
      where: and(
        eq(transcripts.studentId, parsed.data.studentId),
        eq(transcripts.semesterId, parsed.data.semesterId),
      ),
    });

    if (existingTranscript) {
      return { error: 'A transcript for this student in this semester already exists.' };
    }

    const dataToInsert: typeof transcripts.$inferInsert = {
      studentId: parsed.data.studentId,
      semesterId: parsed.data.semesterId,
      gpa: parsed.data.gpa,
      cgpa: parsed.data.cgpa,
      generatedDate: parsed.data.generatedDate,
      fileUrl: parsed.data.fileUrl,
    };

    const newTranscript = await db.insert(transcripts).values(dataToInsert).returning();

    revalidatePath('/dashboard/transcripts');
    revalidatePath(`/dashboard/students/${parsed.data.studentId}/transcripts`);
    return { success: true, data: newTranscript[0] };
  } catch (err: any) {
    console.error('[CREATE_TRANSCRIPT_ACTION_ERROR]', err);
    // If it's a Zod error from transform, it will be caught here
    if (
      err instanceof Error &&
      (err.message.includes('GPA must be') || err.message.includes('CGPA must be'))
    ) {
      return { error: err.message };
    }
    return { error: err.message || 'Failed to create transcript due to a server error.' };
  }
}

/**
 * Fetches all transcripts with associated student, user, and semester details.
 * Permissions: Admin ('admin'), Registrar ('registrar'), Student ('student')
 * Students can only see their own transcripts.
 * @returns An array of transcripts or throws an ActionError.
 */
export async function getTranscripts() {
  try {
    const authUser = await getAuthUser();
    if (!authUser) {
      throw new ActionError('Unauthorized: You must be logged in.');
    }

    // Determine authorization and apply filters
    let studentIdFilter: number | undefined;
    if (authUser.role === ROLES.STUDENT) {
      const studentRecord = await db.query.students.findFirst({
        where: eq(students.userId, authUser.userId),
        columns: { id: true },
      });
      if (!studentRecord) {
        throw new ActionError('Student record not found for the authenticated user.');
      }
      studentIdFilter = studentRecord.id;
    } else if (!checkPermission(authUser, allowedRolesForViewingAllTranscripts())) {
      throw new ActionError('Unauthorized: You do not have permission to view all transcripts.');
    }

    const result = await db
      .select({
        id: transcripts.id,
        studentId: transcripts.studentId,
        semesterId: transcripts.semesterId,
        gpa: transcripts.gpa,
        cgpa: transcripts.cgpa,
        generatedDate: transcripts.generatedDate,
        fileUrl: transcripts.fileUrl,
        studentFirstName: students.firstName,
        studentLastName: students.lastName,
        studentRegNo: students.registrationNumber, // FIX: Use registrationNumber
        studentUserEmail: users.email,
        semesterName: semesters.name,
        // semesterYear: semesters.year, // REMOVED: Not in your schema
        // semesterType: semesters.type, // REMOVED: Not in your schema
      })
      .from(transcripts)
      .leftJoin(students, eq(transcripts.studentId, students.id))
      .leftJoin(users, eq(students.userId, users.id))
      .leftJoin(semesters, eq(transcripts.semesterId, semesters.id))
      .where(studentIdFilter ? eq(transcripts.studentId, studentIdFilter) : undefined); // Apply filter if studentIdFilter is set

    const allTranscripts = result.map((t) => ({
      id: t.id,
      studentId: t.studentId,
      semesterId: t.semesterId,
      gpa: t.gpa,
      cgpa: t.cgpa,
      generatedDate: t.generatedDate,
      fileUrl: t.fileUrl || null,
      studentFullName:
        t.studentFirstName && t.studentLastName ? `${t.studentFirstName} ${t.studentLastName}` : null,
      studentRegNo: t.studentRegNo || null, // FIX: Use aliased name
      studentUserEmail: t.studentUserEmail || null,
      semesterName: t.semesterName || null,
      // semesterYear: t.semesterYear || null, // REMOVED: Not in your schema
      // semesterType: t.semesterType || null, // REMOVED: Not in your schema
    }));

    return allTranscripts;
  } catch (err: any) {
    console.error('[GET_TRANSCRIPTS_ACTION_ERROR]', err);
    throw new ActionError(err.message || 'Failed to fetch transcripts due to a server error.');
  }
}

/**
 * Fetches a single transcript by ID with associated student, user, and semester details.
 * Permissions: Admin ('admin'), Registrar ('registrar'), Student ('student')
 * Students can only see their own transcripts.
 * @param id - The ID of the transcript to fetch.
 * @returns The transcript object or null if not found, or throws an ActionError.
 */
export async function getTranscriptById(id: number) {
  try {
    const authUser = await getAuthUser();
    if (!authUser) {
      return { error: 'Unauthorized: You must be logged in.' };
    }

    const result = await db
      .select({
        id: transcripts.id,
        studentId: transcripts.studentId,
        semesterId: transcripts.semesterId,
        gpa: transcripts.gpa,
        cgpa: transcripts.cgpa,
        generatedDate: transcripts.generatedDate,
        fileUrl: transcripts.fileUrl,
        studentUserId: students.userId, // Needed for permission check
        studentFirstName: students.firstName,
        studentLastName: students.lastName,
        studentRegNo: students.registrationNumber, // FIX: Use registrationNumber
        studentUserEmail: users.email,
        semesterName: semesters.name,
        // semesterYear: semesters.year, // REMOVED: Not in your schema
        // semesterType: semesters.type, // REMOVED: Not in your schema
      })
      .from(transcripts)
      .leftJoin(students, eq(transcripts.studentId, students.id))
      .leftJoin(users, eq(students.userId, users.id))
      .leftJoin(semesters, eq(transcripts.semesterId, semesters.id))
      .where(eq(transcripts.id, id))
      .limit(1);

    const transcriptRecord = result[0];

    if (!transcriptRecord) {
      return { error: 'Transcript not found.' };
    }

    // Check if authorized as Admin, Registrar, or if it's the student's own transcript.
    const isAuthorized =
      checkPermission(authUser, allowedRolesForViewingIndividualTranscript()) ||
      authUser.userId === transcriptRecord.studentUserId;

    if (!isAuthorized) {
      return { error: 'Unauthorized: You do not have permission to view this transcript.' };
    }

    return {
      id: transcriptRecord.id,
      studentId: transcriptRecord.studentId,
      semesterId: transcriptRecord.semesterId,
      gpa: transcriptRecord.gpa,
      cgpa: transcriptRecord.cgpa,
      generatedDate: transcriptRecord.generatedDate,
      fileUrl: transcriptRecord.fileUrl || null,
      studentFullName:
        transcriptRecord.studentFirstName && transcriptRecord.studentLastName
          ? `${transcriptRecord.studentFirstName} ${transcriptRecord.studentLastName}`
          : null,
      studentRegNo: transcriptRecord.studentRegNo || null, // FIX: Use aliased name
      studentUserEmail: transcriptRecord.studentUserEmail || null,
      semesterName: transcriptRecord.semesterName || null,
      // semesterYear: transcriptRecord.semesterYear || null, // REMOVED: Not in your schema
      // semesterType: transcriptRecord.semesterType || null, // REMOVED: Not in your schema
    };
  } catch (err: any) {
    console.error('[GET_TRANSCRIPT_BY_ID_ACTION_ERROR]', err);
    throw new ActionError(err.message || 'Failed to fetch transcript due to a server error.');
  }
}

/**
 * Updates an existing transcript record.
 * Permissions: Admin ('admin'), Registrar ('registrar')
 * @param id - The ID of the transcript to update.
 * @param formData - FormData containing updated transcript details.
 * @returns A success message or an error object.
 */
export async function updateTranscript(id: number, formData: FormData) {
  try {
    const authUser = await getAuthUser();
    if (!authUser || !checkPermission(authUser, allowedRolesForManagingTranscripts())) {
      return { error: 'Unauthorized: You do not have permission to update transcripts.' };
    }

    const parsed = UpdateTranscriptSchema.safeParse({
      studentId: formData.get('studentId'),
      semesterId: formData.get('semesterId'),
      gpa: formData.get('gpa'),
      cgpa: formData.get('cgpa'),
      generatedDate: formData.get('generatedDate'),
      fileUrl: formData.get('fileUrl'),
    });

    if (!parsed.success) {
      console.error('Validation Error:', parsed.error.issues);
      return { error: parsed.error.issues.map((e) => e.message).join(', ') };
    }

    const updates: Partial<typeof transcripts.$inferInsert> = {
      studentId: parsed.data.studentId,
      semesterId: parsed.data.semesterId,
      gpa: parsed.data.gpa,
      cgpa: parsed.data.cgpa,
      generatedDate: parsed.data.generatedDate,
      fileUrl: parsed.data.fileUrl,
    };

    const updatedTranscript = await db
      .update(transcripts)
      .set(updates)
      .where(eq(transcripts.id, id))
      .returning();

    if (updatedTranscript.length === 0) {
      return { error: 'Transcript not found or no changes made.' };
    }

    revalidatePath('/dashboard/transcripts');
    revalidatePath(`/dashboard/transcripts/${id}`);
    if (parsed.data.studentId) {
      revalidatePath(`/dashboard/students/${parsed.data.studentId}/transcripts`);
    }
    return { success: true, data: updatedTranscript[0] };
  } catch (err: any) {
    console.error('[UPDATE_TRANSCRIPT_ACTION_ERROR]', err);
    if (
      err instanceof Error &&
      (err.message.includes('GPA must be') || err.message.includes('CGPA must be'))
    ) {
      return { error: err.message };
    }
    return { error: err.message || 'Failed to update transcript due to a server error.' };
  }
}

/**
 * Deletes a transcript record.
 * Permissions: Admin ('admin'), Registrar ('registrar')
 * @param id - The ID of the transcript to delete.
 * @returns A success message or an error object.
 */
export async function deleteTranscript(id: number) {
  try {
    const authUser = await getAuthUser();
    if (!authUser || !checkPermission(authUser, allowedRolesForManagingTranscripts())) {
      return { error: 'Unauthorized: You do not have permission to delete transcripts.' };
    }

    const transcriptToDelete = await db.query.transcripts.findFirst({
      where: eq(transcripts.id, id),
      columns: { studentId: true },
    });

    const deletedTranscript = await db.delete(transcripts).where(eq(transcripts.id, id)).returning();

    if (deletedTranscript.length === 0) {
      return { error: 'Transcript not found.' };
    }

    revalidatePath('/dashboard/transcripts');
    if (transcriptToDelete?.studentId) {
      revalidatePath(`/dashboard/students/${transcriptToDelete.studentId}/transcripts`);
    }
    return { success: true, data: deletedTranscript[0] };
  } catch (err: any) {
    console.error('[DELETE_TRANSCRIPT_ACTION_ERROR]', err);
    return { error: err.message || 'Failed to delete transcript due to a server error.' };
  }
}

/**
 * Fetches transcripts for a specific student with associated semester details.
 * Permissions: Admin ('admin'), Registrar ('registrar'), Student ('student') - Student can view their own.
 * @param studentId - The ID of the student whose transcripts to fetch.
 * @returns An array of transcripts for the specified student or throws an ActionError.
 */
export async function getTranscriptsByStudentId(studentId: number) {
  try {
    const authUser = await getAuthUser();
    if (!authUser) {
      return { error: 'Unauthorized: You must be logged in.' };
    }

    const studentRecord = await db.query.students.findFirst({
      where: eq(students.id, studentId),
      columns: { userId: true, firstName: true, lastName: true, registrationNumber: true }, // FIX: Use registrationNumber
    });

    if (!studentRecord) {
      return { error: 'Student not found.' };
    }

    // Authorization: Admin, Registrar, or the student themselves.
    const isAuthorized =
      checkPermission(authUser, allowedRolesForManagingTranscripts()) || // Admin, Registrar
      (authUser.role === ROLES.STUDENT && authUser.userId === studentRecord.userId); // Student viewing their own

    if (!isAuthorized) {
      return { error: 'Unauthorized: You do not have permission to view these transcripts.' };
    }

    const result = await db
      .select({
        id: transcripts.id,
        studentId: transcripts.studentId,
        semesterId: transcripts.semesterId,
        gpa: transcripts.gpa,
        cgpa: transcripts.cgpa,
        generatedDate: transcripts.generatedDate,
        fileUrl: transcripts.fileUrl,
        semesterName: semesters.name,
        // semesterYear: semesters.year, // REMOVED: Not in your schema
        // semesterType: semesters.type, // REMOVED: Not in your schema
      })
      .from(transcripts)
      .leftJoin(semesters, eq(transcripts.semesterId, semesters.id))
      .where(eq(transcripts.studentId, studentId));

    const studentTranscripts = result.map((t) => ({
      id: t.id,
      studentId: t.studentId,
      semesterId: t.semesterId,
      gpa: t.gpa,
      cgpa: t.cgpa,
      generatedDate: t.generatedDate,
      fileUrl: t.fileUrl || null,
      semesterName: t.semesterName || null,
      // semesterYear: t.semesterYear || null, // REMOVED: Not in your schema
      // semesterType: t.semesterType || null, // REMOVED: Not in your schema
      // Student details are for the collection, not per-transcript.
      // Can be added outside the map if needed once.
    }));

    return studentTranscripts;
  } catch (err: any) {
    console.error('[GET_TRANSCRIPTS_BY_STUDENT_ID_ACTION_ERROR]', err);
    throw new ActionError('Failed to fetch student transcripts due to a server error: ' + err.message);
  }
}